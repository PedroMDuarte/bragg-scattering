import numpy as np
import vec3
import pylab
from scipy import stats



# Q vector for bragg scattering
l671 = 671.
l1064 = 1064.
Q = 2*np.pi/l1064 * vec3.vec3( -1., -1., 1.)
Qunit = Q/abs(Q)

# Calculate angle for Bragg condition
# with respect to Q vector
braggTH = np.arccos( abs(Q) / 2. / (2.*np.pi/l671)  )  
print "Bragg angle wrt Q = ", braggTH * 180. / np.pi 

# Calculate angle for Bragg condition
# with respect to y axis, when coming from 
# under lattice beam 2. 
from scipy.optimize import root
def cond(x):
    return np.sin(x)-np.cos(x) + 3./2. * l671 / l1064
braggTH2 = (root(cond, 0.).x)[0]
print "Bragg angle wrt -y axis = ", braggTH2 * 180. / np.pi

# Incoming light vector
thi = np.pi/2 - braggTH2
phi = 90. * np.pi / 180.
kin = vec3.vec3()
kin.set_spherical( 2.*np.pi/l671, thi, phi ) 

# Unit vector that points prep to Bragg cone
kinperp = vec3.cross( kin, vec3.cross(Q,kin) ) 
kinperp = kinperp / abs(kinperp)

# Direction of A2 detector
kout = kin + Q  
a2 = kout / abs(kout)
kA2 = kout

# Unit vector perpendicular to plane of Q and A2
Qperp1 = vec3.cross( Q, a2 )
Qperp1 = Qperp1 / abs(Qperp1)

# Unit vector perpendicular to Q and in plane of kin,kout,Q
Qperp2 = vec3.cross( Q, Qperp1)
Qperp2 = Qperp2 / abs(Qperp2)
# Using Qunit and Qperp2 one can use the Bragg angle to 
# easily parameterize vectors near kin and kout

# Define direction of A1 camera
a1 = vec3.vec3()
a1.set_spherical( 1., np.pi/2., np.pi/3. ) 
kA1 = a1*abs(kin)



# The main vectors defined so far are plotted on the sphere here
import bsphere
b = bsphere.Bloch()
origin = vec3.vec3()
b.add_arrow( origin, Q/abs(kin) , 'blue')
b.add_arrow( -kin/abs(kin), origin, 'red')
b.add_arrow( origin, kout/abs(kout), 'red')
b.add_arrow( origin, a1, 'black')
#b.add_arrow( origin, Qperp2, 'green')
#b.show()



import afm
 



# Saturation intensity 
PBragg = 250. # microWatt 
sat = 2.*(PBragg/1000.) / np.pi / (0.05**2)  / 5.21 
print "PBragg = %.2f --> sat = %.2f" % (PBragg, sat)

# Parameters
N = 40 

class Kdet:
    def __init__(self, crystal, kin, kout):

        self.c = crystal

        v0 = [20.,20.,20.]
        kipol = [1., 0]
        PBragg = 250. 
        self.sat = 2.*(PBragg/1000.) / np.pi / (0.05**2)  / 5.21 
      
        self.sunits = 9. * (671e-7**2) / 16 / (np.pi**2) 

        self.pol = self.c.pol(kin, kout, kipol) 
        self.dw  = self.c.debyewaller( kin, kout, v0)

        Nr = 10 # Number of random crystal realizations 
        self.C, self.S = self.c.CS_random( kin, kA1, Nr)
        
 
    def alpha_beta(det):
        self.alpha, self.beta = self.c.alpha_beta_Pbroad( det, self.sat )
 
    def elastic(det):
        if not self.alpha:
            self.alpha_beta(det)
        return self.sunits * self.polsum * self.dw * ( self.alpha * self.C + self.beta * self.S )

    def inelastic(det ):
        if not self.alpha:
            self.alpha_beta(det)
        return self.sunits * self.polsum * self.dw * ( self.alpha * crystal.spin.size \
                                                     + self.beta * 1/4. * crystal.spin.size )

 



import matplotlib.pyplot as plt
import matplotlib

from matplotlib import rc
rc('font',**{'family':'serif'})


cols = 3
rows = 3

figure = plt.figure(figsize=(12.,12.))
#figure.suptitle('Bragg')
gs = matplotlib.gridspec.GridSpec( rows,cols, wspace=0.6, hspace=0.42) 

from uncertainties import unumpy

lc = [ 'black', 'brown', 'red', 'gold', 'limegreen', 'blue', 'purple', 'gray']
fc = [ 'black', 'brown', 'red', 'gold', 'limegreen', 'blue', 'purple', 'gray']
m  = [ 'o', 'D', '+', '^', '<', '>']

ax1e = plt.subplot( gs[ 0,0] )
ax2e = plt.subplot( gs[ 1,0] )
axRe = plt.subplot( gs[ 2,0] )

ax1i = plt.subplot( gs[ 0,1] )
ax2i = plt.subplot( gs[ 1,1] )
axR1ie = plt.subplot( gs[ 2,1] )


ax1c = plt.subplot( gs[ 0,2] )
#ax2c = plt.subplot( gs[ 1,2] )
#axRc = plt.subplot( gs[ 2,2] )

#axlist = [ax1e, ax2e, axRe, ax1i, ax2i, axR1ie, ax1c, ax2c, axRc] 
axlist = [ax1e, ax2e, axRe, ax1i, ax2i, axR1ie] 
for ax in axlist:
  ax.set_xlabel('Detuning ($\Gamma$)')
  # Put vertical lines to show the states
  ax.axvspan(  37.9/5.9-0.5, 37.9/5.9+0.5, facecolor='gray', alpha=0.6, linewidth=0)
  ax.axvspan(  -37.9/5.9-0.5, -37.9/5.9+0.5, facecolor='gray', alpha=0.6, linewidth=0)

ax1e.set_ylabel('ANDOR1')
ax2e.set_ylabel('ANDOR2')
axRe.set_ylabel('A2(elastic)/A1(elastic)')
ax1i.set_ylabel('ANDOR1')
ax2i.set_ylabel('ANDOR2')
axR1ie.set_ylabel('A1(inelastic)/A1(elastic)')

def plotunc( ax, x, dat, lcolor, fcolor, marker, labelstr):
    print "plotting ", labelstr
    ax.errorbar( x, unumpy.nominal_values(dat),\
                yerr=unumpy.std_devs(dat),\
                capsize=0., elinewidth = 1. ,\
                fmt='.', ecolor=lcolor, mec=lcolor, \
                mew=1.0, ms=5.,\
                alpha = 1.0, \
                marker=marker, mfc=fcolor, \
                label=labelstr) 

for i,nafm in enumerate([4,6,8,10,12,16,20,24]):
   
    print "\nWorking on nafm = %d" % nafm 
    # Initialize crystal 
    c = afm.crystal(N, nafm, l1064/2)
        
    A1 = Kdet(c, kin, kA1)
    A2 = Kdet(c, kin, kA2)  

    a1 = []
    a2 = []
    x = np.linspace(-10,10,51) 
    for det in x:
        e1 = A1.elastic(det) 
        i1 = A1.inelastic(det)
        
        e2 = A2.elastic(det)
        i2 = A2.inelastic(det) 

        a1.append( [np.mean(e1), stats.sem(e1), i1 ] ) 
        a2.append( [np.mean(e2), stats.sem(e2), i2 ] )
    a1 = np.array( a1) 
    a2 = np.array( a2) 
     
    # Make the array with uncertainty of the various cross sections
    # for the uncertainty use col=3 which is the standard error
    a1_e = unumpy.uarray( a1[:,0], a1[:,1] )  
    a1_i = unumpy.uarray( a1[:,2], np.zeros_like(a1[:,0]) )
    a2_e = unumpy.uarray( a2[:,0], a2[:,1] )  
    a2_i = unumpy.uarray( a2[:,2], np.zeros_like(a2[:,0]) )

    # PLOT ANDOR 1 
    plotunc( ax1e, x, a1_e, lc[i], 'None', m[i], 'A1 elastic' + ' Nafm=%d'%nafm)
    plotunc( ax1i, x, a1_i, lc[i], 'None', m[i], 'A1 inelastic' + ' Nafm=%d'%nafm)
    print "max a1_i = %f" % unumpy.nominal_values(a1_i).max()
 
    # PLOT ANDOR2
    plotunc( ax2e, x, a2_e, lc[i], 'None', m[i], 'A2 elastic' + ' Nafm=%d'%nafm)
    plotunc( ax2i, x, a2_i, lc[i], 'None', m[i], 'A2 inelastic' + ' Nafm=%d'%nafm)


    # PLOT ANDOR2/ANDOR1 ELASTIC RATIO
    rdat = np.transpose(np.vstack((x, unumpy.nominal_values(a2_e/a1_e))))
    rdat = bindat( rdat, 0, 1, -500., 500., 50)
    xdat = rdat[:,0]
    max0 = rdat[:,1].max() 
    rdat = unumpy.uarray( rdat[:,1], np.ones_like(rdat[:,1]))
    plotunc( axRe, xdat, rdat/max0, lc[i], fc[i],\
             'o', 'Nafm=%d, (x%.2g)'%(nafm,1./max0))

    # PLOT ANDOR2/ANDOR1 INELASTIC RATIO
    rdat = np.transpose(np.vstack((x, unumpy.nominal_values(a1_i/a1_e))))
    rdat = bindat( rdat, 0, 1, -500., 500., 50)
    xdat = rdat[:,0]
    max0 = rdat[:,1].max() 
    rdat = unumpy.uarray( rdat[:,1], np.ones_like(rdat[:,1]))
    plotunc( axR1ie, xdat, rdat/max0, lc[i], fc[i],\
             'o', 'Nafm=%d, (x%.2g)'%(nafm,1./max0))


 


ax1e.set_yscale('log')
ax2e.set_yscale('log')
ax1i.set_yscale('log')
ax2i.set_yscale('log')
#axR.set_yscale('log')

lims=100.
for ax in axlist:
  ax.set_xlim(-lims,lims)
  ax.legend(loc='best', numpoints=1, prop={'size':5})

Rlims=500.
axRe.set_xlim(-Rlims,Rlims)
Rlims=1000.
axR1ie.set_xlim(-Rlims,Rlims)

#ax1i.set_ylim(0.,0.000002)

gs.tight_layout(figure, rect=[0.,0.,1.0,0.91])
#plt.show()
figure.savefig('detuning.png', dpi=200)
#pylab.clf()





